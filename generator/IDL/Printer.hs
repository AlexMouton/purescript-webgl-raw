{-# LANGUAGE OverloadedStrings #-}

module IDL.Printer
( typesFFI
, enumsFFI
, funcsFFI
) where

import Data.Char (toLower, toUpper)
import Data.List (sort)
import Data.Maybe (isNothing)
import Text.PrettyPrint (Doc, ($+$), ($$), (<>), (<+>), brackets, char, empty,
  hcat, integer, nest, parens, punctuate, text, vcat)

import IDL.AST

typesFFI :: IDL -> Doc
typesFFI idl =
    generatedWarning $+$ blank $+$
    header           $+$ blank $+$
    typeDefs         $+$ blank $+$
    typeDecls        $+$ blank
  where
    typeDecls = vcat . map ppTypeDecl . sort $ types idl
    header = vcat
      [ "module Graphics.WebGL.Raw.Types where"
      , ""
      , "import Data.ArrayBuffer.Types"
      , ""
      , "foreign import data WebGL :: !"
      ]

enumsFFI :: IDL -> Doc
enumsFFI idl =
    generatedWarning $+$ blank $+$
    header           $+$ blank $+$
    constants        $+$ blank
  where
    constants = vcat . map ppConstant $ enums idl
    header = vcat
      [ "module Graphics.WebGL.Raw.Enums where"
      , ""
      , "import Graphics.WebGL.Raw.Types"
      , "import qualified Prelude as Pre"
      ]

funcsFFI :: IDL -> Doc
funcsFFI idl =
    generatedWarning $+$ blank $+$
    moduleDef        $+$ blank $+$
    imports          $+$ blank $+$
    methods          $+$ blank
  where
    methods = vcat . map ppFunc $ functions idl
    moduleDef = vcat
      [ "module Graphics.WebGL.Raw"
      , ppExportList (functions idl) $+$ ") where"
      ]
    imports = vcat
      [ "import Control.Monad.Eff"
      , "import Data.ArrayBuffer.Types"
      , "import Data.Function"
      , "import Graphics.WebGL.Raw.Types"
      ]

-- predefined text

generatedWarning :: Doc
generatedWarning = vcat
    [ "-- This file is automatically generated! Don't edit this file, but"
    , "-- instead modify purescript-webgl-generator."
    ]

typeDefs :: Doc
typeDefs = vcat
    [ "type DOMString   = String"
    , "type FloatArray  = Float32Array"
    , "type GLbitfield  = Number"
    , "type GLboolean   = Boolean"
    , "type GLbyte      = Number"
    , "type GLclampf    = Number"
    , "type GLenum      = Number"
    , "type GLfloat     = Number"
    , "type GLint       = Number"
    , "type GLintptr    = Number"
    , "type GLshort     = Number"
    , "type GLsizei     = Number"
    , "type GLsizeiptr  = Number"
    , "type GLubyte     = Number"
    , "type GLuint      = Number"
    , "type GLushort    = Number"
    ]

-- component pretty-printers

ppConstant :: Decl -> Doc
ppConstant Enum { enumName = n, enumValue = v } =
    constName <+> ":: GLenum" $$
    constName <+> "=" <+> (integer v) $$
    blank
  where
    constName = toCamelCase n

ppImplTypeSig :: Decl -> Doc
ppImplTypeSig f@Function{} =
    sigForall f <+> funcType <+> argList <+> parens (sigReturnType f)
  where
    args = funcArgs f
    funcType = "Fn" <> int (length args)
    argList = hcat . punctuate " " $ map (ppConvertType . argType) args

ppRunTypeSig :: Decl -> Doc
ppRunTypeSig f@Function{ methodName = name } =
    text name <+> sigForall f <+> argList
  where
    types = map (ppConvertType . argType) (funcArgs f) ++ [sigReturnType f]
    argList = hcat $ punctuate " -> " types

ppFunc :: Decl -> Doc
ppFunc f@Function{} = ppFuncImpl f $+$ blank $+$ ppRunFunc f $+$ blank

ppRunFunc :: Decl -> Doc
ppRunFunc f@Function{} = ppRunTypeSig f $+$ ppRunFuncBody f

ppRunFuncBody :: Decl -> Doc
ppRunFuncBody f@Function { methodName = name } =
    text name <+> "=" <+>
    "runFn" <> int (length $ funcArgs f) <+>
    implName f

ppFuncImpl :: Decl -> Doc
ppFuncImpl f@Function{} =
    "foreign import" <+> implName f <+> jsBlock $+$
    nest 2 (ppFuncImplBody f) $+$
    jsBlock <+> ppImplTypeSig f
  where
    jsBlock = "\"\"\""

ppFuncImplBody :: Decl -> Doc
ppFuncImplBody f =
    func <+> implName f <> parens (ppArgs funcArgs f) <+> "{" $+$
    nest 2 (ret <+> func <+> "() {") $+$
    nest 4 (ret <+> ppMethod f) $+$
    nest 2 "};" $+$
    "}"
  where
    func = "function"
    ret  = "return"

ppMethod :: Decl -> Doc
ppMethod f@Function{} =
    prefixWebgl <> text (methodName f) <> parens (ppArgs methodArgs f) <> ";"

ppArgs :: (Decl -> [Arg]) -> Decl -> Doc
ppArgs f = hcat . punctuate ", " . map (text . argName) . f

ppTypeDecl :: Type -> Doc
ppTypeDecl Concrete{ typeName = name } =
  "foreign import data" <+> text name <+> ":: *"
ppTypeDecl _ = empty

ppConvertType :: Type -> Doc
ppConvertType Concrete{ typeName = name, typeIsArray = isArray }
    | name == "void"        = toType "Unit"
    | name == "boolean"     = toType "Boolean"
    | name == "ArrayBuffer" = toType "Float32Array"
    | otherwise             = toType name
  where
    toType = if isArray then brackets . text else text
ppConvertType _ = empty

ppExportList :: [Decl] -> Doc
ppExportList = vcat . addOpener . prePunct (", ") . map (text . methodName)
  where
    addOpener (x:xs) = "(" <+> x : xs
    addOpener xs     = xs

sigForall :: Decl -> Doc
sigForall Function{ methodRetType = ret } =
    case ret of
      Generic -> ":: forall eff" <+> genericType <> "."
      _       -> ":: forall eff."

sigReturnType :: Decl -> Doc
sigReturnType Function{ methodRetType = ret } =
    case ret of
      t@Concrete{} -> effMonad <+> ppConvertType t
      _            -> effMonad <+> genericType
  where
    effMonad = "Eff (webgl :: WebGL | eff)"

-- helpers

blank :: Doc
blank = ""

genericType :: Doc
genericType = char 'a'

implName :: Decl -> Doc
implName f@Function{} = text (methodName f) <> "Impl"

int :: Int -> Doc
int = integer . fromIntegral

prefixWebgl :: Doc
prefixWebgl = text (argName webglContext) <> "."

prePunct :: Doc -> [Doc] -> [Doc]
prePunct p (x:x':xs) = x : go x' xs
  where
    go y [] = [p <> y]
    go y (z:zs) = (p <> y) : go z zs
prePunct _ xs = xs

toCamelCase :: String -> Doc
toCamelCase = text . foldr go ""
  where
    go '_' (l:ls) = toUpper l : ls
    go l ls       = toLower l : ls
