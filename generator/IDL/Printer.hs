{-# LANGUAGE OverloadedStrings #-}

module IDL.Printer (ppPureScriptFFI) where

import Data.List (sort)
import Data.Maybe (isNothing)
import Text.PrettyPrint (Doc, ($+$), ($$), (<>), (<+>), brackets, char, empty,
  hcat, integer, lbrace, nest, parens, punctuate, rbrace, semi, space, text,
  vcat)

import IDL.AST

ppPureScriptFFI :: IDL -> Doc
ppPureScriptFFI idl =
        header    $+$ blankLine
    $+$ typeDecls $+$ blankLine
    $+$ constants $+$ blankLine
    $+$ methods   $+$ blankLine
  where
    header = vcat $ moduleHeader ++ [""] ++ typedefs ++ [""] ++ effects
    typeDecls = vcat . map ppTypeDecl . sort $ types idl
    constants = vcat . map ppConstant $ enums idl
    methods = vcat . map ppFuncImpl $ functions idl

-- predefined text

moduleHeader :: [Doc]
moduleHeader =
    [ "-- This file is automatically generated! Don't edit this file, but"
    , "-- instead modify purescript-webgl-generator."
    , ""
    , "module Graphics.WebGL.Raw where"
    , ""
    , "import Control.Monad.Eff"
    , "import Data.ArrayBuffer.Types"
    , "import Data.TypedArray"
    ]

typedefs :: [Doc]
typedefs =
    [ "type ArrayBuffer = Float32Array"
    , "type DOMString   = String"
    , "type FloatArray  = Float32Array"
    , "type GLbitfield  = Number"
    , "type GLboolean   = Boolean"
    , "type GLbyte      = Number"
    , "type GLclampf    = Number"
    , "type GLenum      = Number"
    , "type GLfloat     = Number"
    , "type GLint       = Number"
    , "type GLintptr    = Number"
    , "type GLshort     = Number"
    , "type GLsizei     = Number"
    , "type GLsizeiptr  = Number"
    , "type GLubyte     = Number"
    , "type GLuint      = Number"
    , "type GLushort    = Number"
    ]

effects :: [Doc]
effects = ["foreign import data WebGL :: !"]

-- component pretty-printers

ppConstant :: Decl -> Doc
ppConstant Enum { enumName = n, enumValue = v } =
    text constName <+> "=" $$ nest 48 (integer v)
  where
    constName = '_' : n

ppTypeSig :: Decl -> Doc
ppTypeSig f
    | hasGenericReturnType =
        ":: forall eff a." <+> argList <+> effMonad (char 'a')
    | otherwise =
        ":: forall eff." <+> argList <+> effMonad (ppType $ methodRetType f)
  where
    hasGenericReturnType =
      typeName (methodRetType f) `elem` ["any", "object"]
    effMonad doc =
      parens $ "Eff (webgl :: WebGL | eff)" <+> doc
    argList =
      "Fn" <> text (show . length $ funcArgs f) <+>
      hcat (punctuate space (map (ppType . argType) (funcArgs f)))

ppMethod :: Decl -> Doc
ppMethod f =
    prefixWebgl <> text (methodName f) <> parens (ppArgs methodArgs f) <> semi

ppFuncImplBody :: Decl -> Doc
ppFuncImplBody f =
    func <+> implName f <> parens (ppArgs funcArgs f) <+> lbrace $+$
    nest 2 (ret <+> func <+> parens empty <+> lbrace) $+$
    nest 4 (ret <+> ppMethod f) $+$
    nest 2 rbrace <> semi $+$
    rbrace
  where
    func = "function"
    ret  = "return"

ppArgs :: (Decl -> [Arg]) -> Decl -> Doc
ppArgs f = hcat . punctuate ", " . map (text . argName) . f

ppFuncImpl :: Decl -> Doc
ppFuncImpl f =
    "foreign import" <+> implName f <+>
    jsBlock $+$ nest 2 (ppFuncImplBody f) $+$ jsBlock <+>
    ppTypeSig f $+$ blankLine
  where
    jsBlock = "\"\"\""

ppTypeDecl :: Type -> Doc
ppTypeDecl d = "foreign import data" <+> text (typeName d) <+> ":: *"

ppType :: Type -> Doc
ppType Type { typeName = name, typeIsArray = isArray }
    | name == "void"        = toType "Unit"
    | name == "boolean"     = toType "Boolean"
    | otherwise             = toType name
  where
    toType = if isArray then brackets . text else text

-- helpers

blankLine :: Doc
blankLine = ""

implName :: Decl -> Doc
implName f = text (methodName f) <> "Impl"

prefixWebgl :: Doc
prefixWebgl = text (argName webglContext) <> "."
