module IDL.Printer (ppPureScriptFFI) where

import Data.List (nubBy, nub)
import Data.Maybe (isNothing)
import Text.PrettyPrint
       (sep, ($$), hcat, punctuate, semi, braces, empty, parens, nest,
       (<>), integer, (<+>), text, vcat, ($+$), Doc)

import IDL.AST

moduleHeader :: [String]
moduleHeader =
    [ "-- This file is automatically generated! Don't edit this file, but"
    , "-- instead modify purescript-webgl-generator."
    , ""
    , "module Graphics.WebGLRaw where"
    , ""
    , "import Control.Monad.Eff"
    , "import Control.Monad.Eff.WebGL"
    , "import Data.ArrayBuffer.Types"
    , "import Data.TypedArray"
    ]

typedefs :: [String]
typedefs =
    [ "type GLenum     = Number"
    , "type GLboolean  = Boolean"
    , "type GLbitfield = Number"
    , "type GLbyte     = Number"
    , "type GLshort    = Number"
    , "type GLint      = Number"
    , "type GLsizei    = Number"
    , "type GLintptr   = Number"
    , "type GLsizeiptr = Number"
    , "type GLubyte    = Number"
    , "type GLushort   = Number"
    , "type GLuint     = Number"
    , "type GLfloat    = Number"
    , "type GLclampf   = Number"
    , "type FloatArray = Float32Array"
    ]

webglTypes :: [String]
webglTypes =
    [ "ArrayBuffer"
    , "DOMString"
    , "Float32Array"
    , "FloatArray"
    , "GLbitfield"
    , "GLboolean"
    , "GLbyte"
    , "GLclampf"
    , "GLenum"
    , "GLfloat"
    , "GLint"
    , "GLintptr"
    , "GLshort"
    , "GLsizei"
    , "GLsizeiptr"
    , "GLubyte"
    , "GLuint"
    , "GLushort"
    , "HTMLCanvasElement"
    , "Int32Array"
    , "any"
    , "boolean"
    , "object"
    , "sequence"
    , "void"
    ]

blankLine :: Doc
blankLine = text ""

toPurescriptType :: Type -> Doc
toPurescriptType Type { typeName = t }
    | t == "void"        = text "Unit"
    | t == "boolean"     = text "Boolean"
    | t == "DOMString"   = text "String"
    | t == "ArrayBuffer" = text "Float32Array"
    | otherwise          = text t

ppConstant :: Decl -> Doc
ppConstant Enum { enumName = n, enumValue = v } =
    typeDef $+$ valuDef $+$ blankLine
  where
    typeDef = text constName <+> text ":: Number"
    valuDef = text constName <+> text "=" <+> integer v
    constName = '_' : n

ppTypeSig :: Decl -> Doc
ppTypeSig f
    | hasGenericReturnType =
        text ":: forall eff ret." <+>
        sep ((punctuate (text "->") (map (toPurescriptType . argType) (methodArgs f)))
                ++ [(if null (methodArgs f)
                        then empty
                        else text "->") <+> parens (
                        text "Eff (webgl :: WebGl | eff) ret")])
    | otherwise = text ":: forall eff." <+>
        sep ((punctuate (text "->") (map (toPurescriptType . argType) (methodArgs f)))
                ++ [(if null (methodArgs f)
                        then empty
                        else text "->") <+> parens (
                        text "Eff (webgl :: WebGl | eff)" <+>
                        toPurescriptType (methodRetType f))])
  where
    hasGenericReturnType = typeName (methodRetType f) `elem` ["any", "object"]

ppFuncBodyInner :: Decl -> [Arg] -> Doc
ppFuncBodyInner f (_:tl) =
    text "return" <+> text "function"
        <> parens (if null tl
                    then empty
                    else text (argName (head tl)))
        $$ braces (nest 2 (ppFuncBodyInner f tl)) <> semi
ppFuncBodyInner f []
    | hasNoReturnVal =
        text "gl." <> text (methodName f) <> parens
            (hcat (punctuate (text ",") (map (text . argName) (methodArgs f)))) <>  semi
    | otherwise =
        text "var res = gl." <> text (methodName f) <> parens
            (hcat (punctuate (text ",") (map (text . argName) (methodArgs f)))) <>  semi
        $$ text "if (res === undefined){"
        $$ text "  throw \"Undefined in " <+> text (methodName f) <> text "\"}" <> semi
        $$ text "return res" <> semi
  where hasNoReturnVal = typeName (methodRetType f) == "void"

ppFuncBodyOuter :: Decl -> [Arg] -> Doc
ppFuncBodyOuter f args =
    nest 2 (text "function" <+> text (methodName f) <> text "_" <>
        (parens (if null (methodArgs f)
                    then empty
                    else text (argName (head (methodArgs f))))))
        $$ braces (nest 2 (ppFuncBodyInner f (methodArgs f))) <> semi

ppFunc :: Decl -> Doc
ppFunc f =
    text "foreign import" <+> text (methodName f) <> text "_" $$
        nest 2 (javascriptQuotes (ppFuncBodyOuter f (methodArgs f)) $$
                nest 2 (ppTypeSig f))
            $$ blankLine

ppTypeDecl :: Type -> Doc
ppTypeDecl d = text "foreign import data" <+> text (typeName d) <+> text ":: *"

ppPureScriptFFI :: Idl -> Doc
ppPureScriptFFI idl = header $+$ blankLine
    $+$ text "-- *TypeDecls" $+$ typeDecls $+$ blankLine
    $+$ text "-- *Constants" $+$ constants $+$ blankLine
    $+$ text "-- *Methods"   $+$ methods
  where
    header = vcat . map text $ moduleHeader ++ [""] ++ typedefs

    typeDecls = vcat $ map ppTypeDecl $ nubBy (\t1 t2-> typeName t1 == typeName t2)
                    [t  | d <- idl, t <- extractTypes d, not ((typeName t) `elem` webglTypes)]

    constants = vcat [ppConstant c | c <- idl , isEnum c]

    methods = vcat $ map ppFunc $ nubBy (\t1 t2-> methodName t1 == methodName t2)
                    [c | c <- idl , isUsableFunc c]

javascriptQuotes :: Doc -> Doc
javascriptQuotes p = text "\"\"\"" <> p <> text "\"\"\""

extractTypes :: Decl -> [Type]
extractTypes Function{methodRetType = t1, methodArgs = args} = t1 : map argType args
extractTypes Attribute{attType = t1} = [t1]
extractTypes _ = []

isUsableFunc :: Decl -> Bool
isUsableFunc i =
    isFunction i && and (map (isNothing . typeCondPara . argType) (methodArgs i))
